<?php
/**
*
* This file is part of the phpBB Forum Software package.
*
* @copyright (c) phpBB Limited <https://www.phpbb.com>
* @license GNU General Public License, version 2 (GPL-2.0)
*
* For full copyright and license information, please see
* the docs/CREDITS.txt file.
*
*/

namespace phpbb\bbcode\convert_editor;

use s9e\TextFormatter\Configurator;
use s9e\TextFormatter\Plugins\BBCodes\Configurator as BBCodeConfigurator;
use s9e\TextFormatter\Configurator\Items\AttributeFilters\Regexp as RegexpFilter;
use s9e\TextFormatter\Configurator\Items\UnsafeTemplate;

use phpbb\bbcode\xsl_parse_helper as xsl_parse_helper;

/**
*
*
*/
class sce extends base
{


	/**
	 * Stores all js variables in order to avoid clashes
	 */
	protected $js_variables;

	protected $extra_variables;
	protected $dynamic_variables;

	const DEFAULT_TOOLBAR_BUTTON_GROUP_SIZE = 4;

	/**
	 * Constructor
	 * All variables are passed through to the parent constructor
	 *
	 */
	public function __construct()
	{
		call_user_func_array('parent::__construct', func_get_args());

		$this->js_variables = array();
		$this->extra_variables = array();
		$this->dynamic_variables = NULL;
	}

	public function get_static_javascript_variables()
	{
		return $this->static_js_vars;
	}

	public function get_dynamic_javascript_variables()
	{
		return $this->dynamic_variables;
	}


	/**
	 * @param string original_name A string tried as default value for name (eases readability later).
	 *								It gets suffixed with an integer if it was already defined.
	 * @return A string that has never been generated by this method, in this instance before
	 */
	protected function make_new_js_var($original_name)
	{
		if (!isset($this->js_variables[$original_name]))
		{
			$this->js_variables[$original_name] = 1;
			return $original_name;
		}

		$append = 0;
		do
		{
			$append++;
		}while(isset($this->js_variables[$original_name . $append]));

		$this->js_variables[$original_name . $append] = 1;
		return $original_name . $append;

	}

	protected function parse_case($bbcode_name, &$parsed_child)
	{

		$vars = array();
		foreach ($parsed_child['case'] as $test_result => &$execution)
		{
			foreach ($execution['vars'] as $execution_var)
			{
				if ($execution_var['isAttribute'])
				{
					// $vars[$execution_var['name']] = 1;
					$parsed_child['caseVars'][$execution_var['name']] = 1;
				}
				else
				{
					$this->extra_variables[$execution_var['prefixedName']] = true;
				}
			}

			$this->parse_node($bbcode_name, $execution['children']);
			$execution['js']['type'] = 'SWITCH_CASE';
		}

		$parsed_child['js']['type'] = 'SWITCH_DEFINITION';
	}

	protected function parse_node($bbcode, &$parsed_template)
	{
		// This assumes that there are no text nodes siblings of each other
		// That not being true, however, has only minor performance impact
		$strings = array();

		foreach ($parsed_template as &$parsed_child)
		{
			if (isset($parsed_child['vars']))
			{
				foreach ($parsed_child['vars'] as $var_data)
				{
					if ($var_data['isLanguage'] || $var_data['isSetting'])
					{
						$this->extra_variables[$var_data['prefixedName']] = true;
					}
				}
			}
			if (isset($parsed_child['case']))
			{
				$this->parse_case($bbcode, $parsed_child);
			}
			else
			{
				if ($parsed_child['xsl'])
				{
					switch ($parsed_child['tagName'])
					{
						case 'apply-templates':

							$parsed_child['js']['type'] = 'PARSED_CHILDREN_SET';

						break;
						case 'text':
							// Contains a single text node. It requires special treatment
							$js_var_name = $this->make_new_js_var('textNode');
							$parsed_child['js']['nodeName'] = $js_var_name;
							$parsed_child['js']['nodeText'] = $parsed_child['node']->textContent;
							$parsed_child['js']['type'] = 'CONSTANT_TEXT_NODE_DEFINITION';
							$parsed_child['children'] = array();

						break;
						case 'attribute':
							// Contains multiple nodes to form a string to write into an atribute
							$js_var_name = $this->make_new_js_var('attributeBuildDoc');
							$parsed_child['js']['nodeName'] = $js_var_name;
							$parsed_child['js']['attributeName'] = $parsed_child['node']->getAttribute('name');
							$parsed_child['js']['type'] = 'ATTRIBUTES_FOR_ELEMENT_DEFINITION';

						break;
						case 'value-of':
							// Here it is easier due to how TextFormatter uses this tag
							$var_data = $parsed_child['vars'][0];
							$js_var_name = $this->make_new_js_var('textNode');

							$parsed_child['js']['nodeName'] = $js_var_name;
							$parsed_child['js']['type'] = 'ATTRIBUTE_TEXT_NODE_DEFINITION';
							$parsed_child['js']['parentEditable'] = $var_data['isAttribute'];
							$parsed_child['js']['varName'] = $var_data['name'];
						break;


					}
				}
				else
				{
					if ($parsed_child['tagName'][0] === '#')
					{
						// Contains a single text node. It requires special treatment
						$js_var_name = $this->make_new_js_var('textNode');
						$parsed_child['js']['nodeName'] = $js_var_name;
						$parsed_child['js']['nodeText'] = $parsed_child['node']->data;
						$parsed_child['js']['type'] = 'CONSTANT_TEXT_NODE_DEFINITION';
						$parsed_child['children'] = array();
					}
					else
					{

						$tag_attributes = array();
						$bbcode_attributes = array();

						foreach ($parsed_child['node']->attributes as $attribute)
						{
							$tag_attributes[$attribute->nodeName] = "'" . $attribute->value . "'";
						}
						if (isset($parsed_child['vars']))
						{
							foreach ($parsed_child['vars'] as $var)
							{
								$tag_attributes[$var['attr']] = preg_replace_callback(
									// Note: The lookaround are required in case multiple variables are next to eachother
									"%((?<=[^'])|')" . preg_quote('{$' . $var['prefixedName'] . '}', '%') . "((?=[^'])|')%",
									function ($match) use ($var, &$tag_attributes, &$bbcode_attributes)
									{
										$replacement = '';
										if ($match[1] !== "'")
										{
											$replacement .= "' + ";
										}
										if ($var['isAttribute'])
										{
											$replacement .= "attributes['" . $var['name'] . "']";
											$bbcode_attributes[$var['attr']] = $var['name'];
										}
										else
										{
											$replacement = xsl_parse_helper::EDITOR_JS_GLOBAL_OBJ . '.' . $var['prefixedName'];
											$this->extra_variables[$var['prefixedName']] = true;
										}
										if ($match[2] !== "'")
										{
											$replacement .= " + '";
										}
										return $replacement;
									},
									$tag_attributes[$var['attr']]
								);
							}
						}
						$js_var_name = $this->make_new_js_var($parsed_child['tagName'] . 'Tag');

						$parsed_child['js']['tagName'] = $parsed_child['tagName'];
						$parsed_child['js']['attributes'] = $tag_attributes;
						$parsed_child['js']['bbcodeAttributes'] = $bbcode_attributes;
						$parsed_child['js']['type'] = 'NODE_DEFINITION';
						$parsed_child['js']['nodeName'] = $js_var_name;
					}
				}

				$node_children = &$parsed_child['children'];

				$this->parse_node($bbcode, $node_children);
			}
		}
	}

	/**
	 * This converts the BBCode in the format that is in the database into a javascript output
	 * which is the instructions for the WYSIWYG editor on how to display all the BBCode and which BBCode
	 * to show up on the BBCode button list
	 *
	 *
	 *
	 */
	public function generate_editor_setup_javascript($text_formatter_factory)
	{

		$configurator = $text_formatter_factory->get_configurator();
		$configurator->addHTML5Rules();
		$configurator->enableJavaScript();

		$xsl_helper = new \phpbb\bbcode\xsl_parse_helper();
		$xsl_helper->translate_attribute_vars_to_params(true);
		$parsed_templates = $xsl_helper->parse_tag_templates($configurator->BBCodes, $configurator->tags);
		$xsl_text = $xsl_helper->get_built_xsl_sheet();

		$template_tree_definition = array();

		$template_tree_definition['xsl'] = str_replace("\n", "' +\n'", addcslashes($xsl_text, "'"));

		$template_tree_definition['bbcodes'] = array();

		$bbcodes_data = $this->extract_and_normalize_bbcode_data($configurator->BBCodes, $configurator->tags, true);

		$tree_definition = &$template_tree_definition['bbcodes'];

		$tag_id = -1;
		$js_texts = array();

		foreach ($configurator->BBCodes as $bbcode_name => $bbcode)
		{
			$tag_id++;
			$bbcode_name = strtolower($bbcode_name);

			$tree_definition[$bbcode_name] = array();
			$bbcode_definition = &$tree_definition[$bbcode_name];

			$bbcode_definition['name'] = $bbcode_name;
			$bbcode_definition['tagId'] = $tag_id;

			$bbcode_data = &$bbcodes_data[$bbcode_name];
			$bbcode_definition['data'] = &$bbcode_data;
			if (isset($bbcode_data['override']))
			{
				$bbcode_definition['override'] = $bbcode_data['override'];
			}

			if (isset($bbcode_data['tooltip_lang']))
			{
				$this->extra_variables[$bbcode_data['tooltip_lang']] = true;
			}

			$parsed_template = $parsed_templates[$bbcode_name];
			$bbcode_definition['parsedTemplate'] = &$parsed_template;

			$tag = $configurator->tags[$bbcode->tagName];
			$container_tags = $this->get_container_tags($parsed_template);
			$bbcode_definition['containerTags'] = array_unique($container_tags);

			foreach ($bbcode_data['attrPresets'] as $name => &$value)
			{
				$value = addcslashes($value, '"');
			}

			$this->parse_node($bbcode_name, $parsed_template);

			// This should happen when it reaches the end of the block... Sounds like it isn't
			unset($parsed_template);
		}

		$overrides = array();

		$this->setup_default_bbcodes($template_tree_definition['bbcodes'], $overrides);

		$this->static_js_vars = array(
			'XSLT' => $template_tree_definition['xsl'],
			'BBCODES' => $template_tree_definition['bbcodes'],
			'OVERRIDES' => $overrides,
		);

		$this->dynamic_variables = array(
			'JS_BBCODE_VARS_CONTAINER' => xsl_parse_helper::EDITOR_JS_GLOBAL_OBJ,
			'JS_BBCODE_VARS' => array_keys($this->extra_variables),
		);

	}

	public function setup_default_bbcodes(&$bbcode_definition, &$overrides)
	{

		// size is special... It uses a dropdown...
		$this->size_override($bbcode_definition['size']['data']);

		$overrides['toolbar'] = $this->toolbar_override($this->toolbar_default_ordering, $bbcode_definition);
	}

	public function size_override(&$bbcode_data)
	{
		$this->extra_variables['L_FONT_TINY'] = true;
		$this->extra_variables['L_FONT_SMALL'] = true;
		$this->extra_variables['L_FONT_NORMAL'] = true;
		$this->extra_variables['L_FONT_LARGE'] = true;
		$this->extra_variables['L_FONT_HUGE'] = true;

		$bbcode_data['attr']['size'] = array(
			'type' => 'choose1',
			'options' => array(
				array(
					'langText' => 'L_FONT_TINY',
					'value' => '50',
				),
				array(
					'langText' => 'L_FONT_SMALL',
					'value' => '85',
				),
				array(
					'langText' => 'L_FONT_NORMAL',
					'value' => '100',
					'selected' => true,
				),
				array(
					'langText' => 'L_FONT_LARGE',
					'value' => '150',
				),
				array(
					'langText' => 'L_FONT_HUGE',
					'value' => '200',
				),
			),
		) + $bbcode_data['attr']['size'];

	}

	public function toolbar_override($defined_bbcode, $tree_definition){
		$predefined_bbcode_names = array();

		$toolbar_buttons = '';

		foreach ($defined_bbcode as $button_group)
		{
			foreach ($button_group as $button_name)
			{
				$predefined_bbcode_names[$button_name] = true;
				$toolbar_buttons .= $button_name . ',';
			}
			$toolbar_buttons .= '|';
		}

		$separator_counter = 1;

		foreach ($tree_definition as $name => $something)
		{
			if (!isset($predefined_bbcode_names[$name]))
			{
				$toolbar_buttons .= $name;
				if ($separator_counter % self::DEFAULT_TOOLBAR_BUTTON_GROUP_SIZE)
				{
					$toolbar_buttons .= ',';
				}
				else
				{
					$toolbar_buttons .= '|';
				}
				$separator_counter++;
			}
		}

		return $toolbar_buttons;
	}

	public function get_name(){
		return 'SCE';
	}

	public function get_available_modes()
	{
		return parent::DEFAULT_WYSIWYG_MODE | parent::DEFAULT_SOURCE_MODE;
	}

	public function get_available_button_modes()
	{
		return parent::HAS_BUTTON_MODE_ICON | parent::HAS_BUTTON_MODE_TEXT | parent::HAS_BUTTON_MODE_ICON_TEXT;
	}

}
